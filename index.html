<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    
    <!-- Tailwind配置 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        dark: '#1E293B',
                        light: '#F8FAFC',
                        accent: '#8B5CF6',
                        danger: '#EF4444',
                        neutral: '#64748B'
                    },
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .tool-active {
                @apply bg-primary/10 text-primary border-primary;
            }
            .panel-shadow {
                @apply shadow-lg shadow-black/5;
            }
            .node-transition {
                @apply transition-all duration-150 ease-out;
            }
            .canvas-grid {
                background-size: 20px 20px;
                background-image: 
                    linear-gradient(to right, rgba(0, 0, 0, 0.05) 1px, transparent 1px),
                    linear-gradient(to bottom, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
            }
        }
    </style>
</head>
<body class="font-inter bg-gray-50 text-dark overflow-hidden h-screen flex flex-col">
    <!-- 顶部导航栏 -->
    <header class="bg-white border-b border-gray-200 py-2 px-4 flex items-center justify-between z-10">
        <div class="flex items-center space-x-4">
            <h1 class="text-xl font-bold text-primary flex items-center">
                <i class="fa fa-sitemap mr-2"></i>
                <span>Graph Editor</span>
            </h1>
            
            <div class="hidden md:flex space-x-1">
                <button class="px-3 py-1 text-sm rounded hover:bg-gray-100 transition-colors flex items-center">
                    <a href="https://www.luogu.com.cn">洛谷</a>
                </button>
                <button class="px-3 py-1 text-sm rounded hover:bg-gray-100 transition-colors flex items-center">
                    <a href="https://vjudge.net">vjudge</a>
                </button>
            </div>
        </div>
        
        <div class="flex items-center space-x-3">
            <div class="flex items-center bg-gray-100 rounded-full px-3 py-1 text-sm">
                <button id="zoom-out" class="p-1 hover:bg-gray-200 rounded-full transition-colors">
                    <i class="fa fa-minus"></i>
                </button>
                <span id="zoom-level" class="mx-2 w-12 text-center">100%</span>
                <button id="zoom-in" class="p-1 hover:bg-gray-200 rounded-full transition-colors">
                    <i class="fa fa-plus"></i>
                </button>
                <button id="zoom-reset" class="p-1 hover:bg-gray-200 rounded-full transition-colors ml-1">
                    <i class="fa fa-arrows-alt"></i>
                </button>
            </div>
            
            <button class="md:hidden p-2 rounded hover:bg-gray-100 transition-colors">
                <i class="fa fa-bars"></i>
            </button>
        </div>
    </header>
    
    <!-- 主内容区 -->
    <main class="flex flex-1 overflow-hidden">
        <!-- 左侧工具栏 -->
        <aside class="w-12 bg-white border-r border-gray-200 panel-shadow flex flex-col items-center py-3 space-y-2 z-10">
            <button id="select-tool" class="tool-active w-8 h-8 rounded flex items-center justify-center border border-gray-300 hover:bg-gray-50 transition-colors" title="Select Tool (V)">
                <i class="fa fa-mouse-pointer"></i>
            </button>
            <button id="node-tool" class="w-8 h-8 rounded flex items-center justify-center border border-gray-300 hover:bg-gray-50 transition-colors" title="Add Node (N)">
                <i class="fa fa-circle-o text-sm"></i>
            </button>
            <button id="edge-tool" class="w-8 h-8 rounded flex items-center justify-center border border-gray-300 hover:bg-gray-50 transition-colors" title="Add Edge (E)">
                <i class="fa fa-minus text-xs"></i>
            </button>
            <button id="delete-tool" class="w-8 h-8 rounded flex items-center justify-center border border-gray-300 hover:bg-gray-50 transition-colors" title="Delete (Delete)">
                <i class="fa fa-trash-o"></i>
            </button>
            
            <div class="w-6 h-px bg-gray-200 my-2"></div>
            
            <button class="w-8 h-8 rounded flex items-center justify-center border border-gray-300 hover:bg-gray-50 transition-colors" title="Undo (Ctrl+Z)">
                <i class="fa fa-undo"></i>
            </button>
            <button class="w-8 h-8 rounded flex items-center justify-center border border-gray-300 hover:bg-gray-50 transition-colors" title="Redo (Ctrl+Y)">
                <i class="fa fa-repeat"></i>
            </button>
            
            <div class="w-6 h-px bg-gray-200 my-2"></div>
            
            <button id="layout-auto" class="w-8 h-8 rounded flex items-center justify-center border border-gray-300 hover:bg-gray-50 transition-colors" title="Auto Layout">
                <i class="fa fa-magic"></i>
            </button>
            <button id="layout-circle" class="w-8 h-8 rounded flex items-center justify-center border border-gray-300 hover:bg-gray-50 transition-colors" title="Circle Layout">
                <i class="fa fa-circle text-xs"></i>
            </button>
        </aside>
        
        <!-- 画布区域 -->
        <div id="canvas-container" class="flex-1 relative overflow-hidden bg-gray-100">
            <canvas id="graph-canvas" class="absolute inset-0 canvas-grid"></canvas>
        </div>
        
        <!-- 右侧属性面板 -->
        <aside id="properties-panel" class="w-64 bg-white border-l border-gray-200 panel-shadow flex flex-col hidden lg:flex">
            <div class="p-3 border-b border-gray-200">
                <h2 class="font-semibold">Properties</h2>
            </div>
            
            <div id="no-selection" class="flex-1 flex flex-col items-center justify-center text-neutral p-4 text-center">
                <i class="fa fa-hand-pointer-o text-4xl mb-3 opacity-50"></i>
                <p>Select a node or edge to edit its properties</p>
            </div>
            
            <div id="node-properties" class="flex-1 p-4 hidden">
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Node ID</label>
                    <input type="text" id="node-id" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary text-sm">
                </div>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Label</label>
                    <input type="text" id="node-label" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary text-sm">
                </div>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Fill Color</label>
                    <div class="flex items-center space-x-2">
                        <input type="color" id="node-color" class="w-8 h-8 p-0 border border-gray-300 rounded" value="#3B82F6">
                        <input type="text" id="node-color-text" class="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary text-sm" value="#3B82F6">
                    </div>
                </div>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Border Color</label>
                    <div class="flex items-center space-x-2">
                        <input type="color" id="node-border-color" class="w-8 h-8 p-0 border border-gray-300 rounded" value="#1D4ED8">
                        <input type="text" id="node-border-text" class="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary text-sm" value="#1D4ED8">
                    </div>
                </div>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Size</label>
                    <input type="number" id="node-size" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary text-sm" value="30" min="10" max="100">
                </div>
            </div>
            
            <div id="edge-properties" class="flex-1 p-4 hidden">
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Edge ID</label>
                    <input type="text" id="edge-id" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary text-sm">
                </div>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Label</label>
                    <input type="text" id="edge-label" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary text-sm">
                </div>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Color</label>
                    <div class="flex items-center space-x-2">
                        <input type="color" id="edge-color" class="w-8 h-8 p-0 border border-gray-300 rounded" value="#64748B">
                        <input type="text" id="edge-color-text" class="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary text-sm" value="#64748B">
                    </div>
                </div>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Width</label>
                    <input type="number" id="edge-width" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary text-sm" value="2" min="1" max="10">
                </div>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Type</label>
                    <select id="edge-type" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary text-sm">
                        <option value="straight">Straight</option>
                        <option value="curved">Curved</option>
                        <option value="dashed">Dashed</option>
                    </select>
                </div>
            </div>
        </aside>
    </main>
    
    <!-- 底部状态栏 -->
    <footer class="bg-white border-t border-gray-200 py-1 px-4 text-xs text-neutral flex justify-between">
        <div>
            Nodes: <span id="node-count">0</span> | Edges: <span id="edge-count">0</span>
        </div>
        <div>
            <span class="mr-4">Press H for help</span>
            <span>v1.0</span>
        </div>
    </footer>

    <script>
        // 图形数据模型
        class Graph {
            constructor() {
                this.nodes = new Map();
                this.edges = new Map();
                this.nextNodeId = 1;
                this.nextEdgeId = 1;
            }
            
            addNode(x, y, label = '') {
                const id = `n${this.nextNodeId++}`;
                const node = {
                    id,
                    x,
                    y,
                    label: label || id,
                    color: '#3B82F6',
                    borderColor: '#1D4ED8',
                    size: 30
                };
                this.nodes.set(id, node);
                return node;
            }
            
            addEdge(sourceId, targetId, label = '') {
                // 检查节点是否存在
                if (!this.nodes.has(sourceId) || !this.nodes.has(targetId)) {
                    return null;
                }
                
                // 检查边是否已存在
                for (const edge of this.edges.values()) {
                    if ((edge.source === sourceId && edge.target === targetId) ||
                        (edge.source === targetId && edge.target === sourceId)) {
                        return null;
                    }
                }
                
                const id = `e${this.nextEdgeId++}`;
                const edge = {
                    id,
                    source: sourceId,
                    target: targetId,
                    label: label || '',
                    color: '#64748B',
                    width: 2,
                    type: 'straight'
                };
                this.edges.set(id, edge);
                return edge;
            }
            
            removeNode(id) {
                if (!this.nodes.has(id)) return false;
                
                // 移除所有关联的边
                this.edges.forEach((edge, edgeId) => {
                    if (edge.source === id || edge.target === id) {
                        this.edges.delete(edgeId);
                    }
                });
                
                this.nodes.delete(id);
                return true;
            }
            
            removeEdge(id) {
                if (!this.edges.has(id)) return false;
                this.edges.delete(id);
                return true;
            }
            
            getNode(id) {
                return this.nodes.get(id);
            }
            
            getEdge(id) {
                return this.edges.get(id);
            }
            
            updateNode(id, data) {
                const node = this.getNode(id);
                if (!node) return false;
                Object.assign(node, data);
                return true;
            }
            
            updateEdge(id, data) {
                const edge = this.getEdge(id);
                if (!edge) return false;
                Object.assign(edge, data);
                return true;
            }
            
            clear() {
                this.nodes.clear();
                this.edges.clear();
                this.nextNodeId = 1;
                this.nextEdgeId = 1;
            }
            
            // 应用圆形布局
            applyCircleLayout(radius = 200) {
                const nodes = Array.from(this.nodes.values());
                const count = nodes.length;
                if (count <= 1) return;
                
                const centerX = canvas.width / 2 / zoom + panX;
                const centerY = canvas.height / 2 / zoom + panY;
                
                nodes.forEach((node, index) => {
                    const angle = (index / count) * Math.PI * 2;
                    node.x = centerX + radius * Math.cos(angle);
                    node.y = centerY + radius * Math.sin(angle);
                });
            }
            
            // 应用力导向布局（简化版）
            applyForceLayout(iterations = 50) {
                const nodes = Array.from(this.nodes.values());
                const edges = Array.from(this.edges.values());
                
                // 初始化速度
                nodes.forEach(node => {
                    node.vx = 0;
                    node.vy = 0;
                });
                
                for (let i = 0; i < iterations; i++) {
                    // 重置力
                    nodes.forEach(node => {
                        node.fx = 0;
                        node.fy = 0;
                    });
                    
                    // 节点间的排斥力
                    for (let a = 0; a < nodes.length; a++) {
                        for (let b = a + 1; b < nodes.length; b++) {
                            const nodeA = nodes[a];
                            const nodeB = nodes[b];
                            
                            const dx = nodeB.x - nodeA.x;
                            const dy = nodeB.y - nodeA.y;
                            const distance = Math.sqrt(dx * dx + dy * dy) || 0.1;
                            const repulsion = 10000 / (distance * distance);
                            
                            const fx = repulsion * (dx / distance);
                            const fy = repulsion * (dy / distance);
                            
                            nodeA.fx -= fx;
                            nodeA.fy -= fy;
                            nodeB.fx += fx;
                            nodeB.fy += fy;
                        }
                    }
                    
                    // 边上的吸引力
                    edges.forEach(edge => {
                        const source = this.getNode(edge.source);
                        const target = this.getNode(edge.target);
                        if (!source || !target) return;
                        
                        const dx = target.x - source.x;
                        const dy = target.y - source.y;
                        const distance = Math.sqrt(dx * dx + dy * dy) || 0.1;
                        const desiredDistance = 100;
                        const attraction = 0.1 * (distance - desiredDistance);
                        
                        const fx = attraction * (dx / distance);
                        const fy = attraction * (dy / distance);
                        
                        source.fx += fx;
                        source.fy += fy;
                        target.fx -= fx;
                        target.fy -= fy;
                    });
                    
                    // 应用力并更新位置
                    nodes.forEach(node => {
                        // 阻尼
                        node.vx = (node.vx + node.fx) * 0.5;
                        node.vy = (node.vy + node.fy) * 0.5;
                        
                        // 更新位置
                        node.x += node.vx;
                        node.y += node.vy;
                        
                        // 边界检查
                        node.x = Math.max(50, Math.min(canvas.width / zoom - 50, node.x));
                        node.y = Math.max(50, Math.min(canvas.height / zoom - 50, node.y));
                    });
                }
            }
        }
        
        // 全局变量
        const graph = new Graph();
        let canvas, ctx;
        let panX = 0, panY = 0;
        let zoom = 1;
        let isDragging = false;
        let dragStartX, dragStartY;
        let selectedNode = null;
        let selectedEdge = null;
        let hoveredNode = null;
        let hoveredEdge = null;
        let currentTool = 'select';
        let edgeStartNode = null;
        
        // 初始化
        function init() {
            canvas = document.getElementById('graph-canvas');
            ctx = canvas.getContext('2d');
            
            // 设置canvas尺寸
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // 工具选择
            document.getElementById('select-tool').addEventListener('click', () => setTool('select'));
            document.getElementById('node-tool').addEventListener('click', () => setTool('node'));
            document.getElementById('edge-tool').addEventListener('click', () => setTool('edge'));
            document.getElementById('delete-tool').addEventListener('click', () => setTool('delete'));
            
            // 布局按钮
            document.getElementById('layout-auto').addEventListener('click', () => {
                graph.applyForceLayout();
                render();
            });
            document.getElementById('layout-circle').addEventListener('click', () => {
                graph.applyCircleLayout();
                render();
            });
            
            // 缩放控制
            document.getElementById('zoom-in').addEventListener('click', () => {
                zoom = Math.min(zoom * 1.2, 5);
                updateZoomDisplay();
                render();
            });
            
            document.getElementById('zoom-out').addEventListener('click', () => {
                zoom = Math.max(zoom / 1.2, 0.1);
                updateZoomDisplay();
                render();
            });
            
            document.getElementById('zoom-reset').addEventListener('click', () => {
                zoom = 1;
                panX = 0;
                panY = 0;
                updateZoomDisplay();
                render();
            });
            
            // 属性面板输入事件
            setupPropertyInputs();
            
            // 画布事件
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            
            // 键盘事件
            window.addEventListener('keydown', handleKeyDown);
            
            // 初始化一些示例节点
            addExampleGraph();
            render();
        }
        
        // 设置工具
        function setTool(tool) {
            currentTool = tool;
            
            // 重置工具按钮样式
            document.querySelectorAll('aside button').forEach(btn => {
                btn.classList.remove('tool-active');
            });
            
            // 设置当前工具按钮样式
            document.getElementById(`${tool}-tool`).classList.add('tool-active');
            
            // 重置状态
            edgeStartNode = null;
            deselectAll();
        }
        
        // 处理鼠标按下事件
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / zoom - panX;
            const y = (e.clientY - rect.top) / zoom - panY;
            
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            
            // 检查是否点击了节点
            const clickedNode = findNodeAt(x, y);
            
            // 检查是否点击了边
            const clickedEdge = findEdgeAt(e.clientX - rect.left, e.clientY - rect.top);
            
            switch (currentTool) {
                case 'select':
                    if (clickedNode) {
                        selectNode(clickedNode.id);
                        isDragging = true;
                    } else if (clickedEdge) {
                        selectEdge(clickedEdge.id);
                        isDragging = false;
                    } else {
                        deselectAll();
                        isDragging = true; // 开始平移
                    }
                    break;
                    
                case 'node':
                    deselectAll();
                    graph.addNode(x, y);
                    updateCounters();
                    render();
                    break;
                    
                case 'edge':
                    if (clickedNode) {
                        if (edgeStartNode === null) {
                            edgeStartNode = clickedNode.id;
                            selectNode(clickedNode.id);
                        } else if (edgeStartNode !== clickedNode.id) {
                            graph.addEdge(edgeStartNode, clickedNode.id);
                            edgeStartNode = null;
                            deselectAll();
                            updateCounters();
                            render();
                        }
                    }
                    break;
                    
                case 'delete':
                    if (clickedNode) {
                        graph.removeNode(clickedNode.id);
                        deselectAll();
                    } else if (clickedEdge) {
                        graph.removeEdge(clickedEdge.id);
                        deselectAll();
                    }
                    updateCounters();
                    render();
                    break;
            }
        }
        
        // 处理鼠标移动事件
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / zoom - panX;
            const y = (e.clientY - rect.top) / zoom - panY;
            
            // 更新悬停状态
            const newHoveredNode = findNodeAt(x, y);
            const newHoveredEdge = findEdgeAt(e.clientX - rect.left, e.clientY - rect.top);
            
            if (newHoveredNode !== hoveredNode || newHoveredEdge !== hoveredEdge) {
                hoveredNode = newHoveredNode;
                hoveredEdge = newHoveredEdge;
                render();
            }
            
            if (isDragging) {
                if (currentTool === 'select' && selectedNode) {
                    // 拖动节点
                    graph.updateNode(selectedNode, { x, y });
                    render();
                } else if (!selectedNode && !selectedEdge) {
                    // 平移画布
                    panX += (dragStartX - e.clientX) / zoom;
                    panY += (dragStartY - e.clientY) / zoom;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    render();
                }
            }
        }
        
        // 处理鼠标释放事件
        function handleMouseUp() {
            isDragging = false;
        }
        
        // 处理鼠标滚轮事件（缩放）
        function handleWheel(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // 缩放前的鼠标世界坐标
            const worldX = mouseX / zoom - panX;
            const worldY = mouseY / zoom - panY;
            
            // 应用缩放
            if (e.deltaY < 0) {
                zoom = Math.min(zoom * 1.1, 5);
            } else {
                zoom = Math.max(zoom / 1.1, 0.1);
            }
            
            // 调整平移，使鼠标指向的点保持不变
            panX = mouseX / zoom - worldX;
            panY = mouseY / zoom - worldY;
            
            updateZoomDisplay();
            render();
        }
        
        // 处理键盘事件
        function handleKeyDown(e) {
            // 删除键
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedNode) {
                    graph.removeNode(selectedNode);
                    deselectAll();
                } else if (selectedEdge) {
                    graph.removeEdge(selectedEdge);
                    deselectAll();
                }
                updateCounters();
                render();
            }
            
            // 快捷键
            switch (e.key.toLowerCase()) {
                case 'v':
                    setTool('select');
                    break;
                case 'n':
                    setTool('node');
                    break;
                case 'e':
                    setTool('edge');
                    break;
                case 'z':
                    if (e.ctrlKey || e.metaKey) {
                        // 撤销操作（简化版）
                        console.log('Undo');
                    }
                    break;
                case 'y':
                    if (e.ctrlKey || e.metaKey) {
                        // 重做操作（简化版）
                        console.log('Redo');
                    }
                    break;
            }
        }
        
        // 查找指定位置的节点
        function findNodeAt(x, y) {
            for (const node of graph.nodes.values()) {
                const dx = x - node.x;
                const dy = y - node.y;
                if (dx * dx + dy * dy <= node.size * node.size) {
                    return node;
                }
            }
            return null;
        }
        
        // 查找指定位置的边（屏幕坐标）
        function findEdgeAt(screenX, screenY) {
            const threshold = 5; // 点击边的阈值（像素）
            
            for (const edge of graph.edges.values()) {
                const source = graph.getNode(edge.source);
                const target = graph.getNode(edge.target);
                
                if (!source || !target) continue;
                
                // 转换为屏幕坐标
                const x1 = (source.x + panX) * zoom;
                const y1 = (source.y + panY) * zoom;
                const x2 = (target.x + panX) * zoom;
                const y2 = (target.y + panY) * zoom;
                
                // 计算点到线段的距离
                const distance = pointToLineDistance(screenX, screenY, x1, y1, x2, y2);
                
                if (distance <= threshold) {
                    return edge;
                }
            }
            
            return null;
        }
        
        // 计算点到线段的距离
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            // 线段长度的平方
            const l2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            if (l2 === 0) return Math.hypot(px - x1, py - y1);
            
            // 计算投影比例
            let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
            t = Math.max(0, Math.min(1, t));
            
            // 投影点
            const projX = x1 + t * (x2 - x1);
            const projY = y1 + t * (y2 - y1);
            
            // 距离
            return Math.hypot(px - projX, py - projY);
        }
        
        // 选择节点
        function selectNode(nodeId) {
            selectedNode = nodeId;
            selectedEdge = null;
            
            // 更新属性面板
            const node = graph.getNode(nodeId);
            if (node) {
                document.getElementById('node-id').value = node.id;
                document.getElementById('node-label').value = node.label;
                document.getElementById('node-color').value = node.color;
                document.getElementById('node-color-text').value = node.color;
                document.getElementById('node-border-color').value = node.borderColor;
                document.getElementById('node-border-text').value = node.borderColor;
                document.getElementById('node-size').value = node.size;
                
                document.getElementById('no-selection').classList.add('hidden');
                document.getElementById('node-properties').classList.remove('hidden');
                document.getElementById('edge-properties').classList.add('hidden');
            }
            
            render();
        }
        
        // 选择边
        function selectEdge(edgeId) {
            selectedEdge = edgeId;
            selectedNode = null;
            
            // 更新属性面板
            const edge = graph.getEdge(edgeId);
            if (edge) {
                document.getElementById('edge-id').value = edge.id;
                document.getElementById('edge-label').value = edge.label;
                document.getElementById('edge-color').value = edge.color;
                document.getElementById('edge-color-text').value = edge.color;
                document.getElementById('edge-width').value = edge.width;
                document.getElementById('edge-type').value = edge.type;
                
                document.getElementById('no-selection').classList.add('hidden');
                document.getElementById('node-properties').classList.add('hidden');
                document.getElementById('edge-properties').classList.remove('hidden');
            }
            
            render();
        }
        
        // 取消所有选择
        function deselectAll() {
            selectedNode = null;
            selectedEdge = null;
            
            // 更新属性面板
            document.getElementById('no-selection').classList.remove('hidden');
            document.getElementById('node-properties').classList.add('hidden');
            document.getElementById('edge-properties').classList.add('hidden');
            
            render();
        }
        
        // 设置属性面板输入事件
        function setupPropertyInputs() {
            // 节点属性
            document.getElementById('node-id').addEventListener('change', (e) => {
                if (selectedNode) {
                    graph.updateNode(selectedNode, { id: e.target.value });
                    render();
                }
            });
            
            document.getElementById('node-label').addEventListener('change', (e) => {
                if (selectedNode) {
                    graph.updateNode(selectedNode, { label: e.target.value });
                    render();
                }
            });
            
            document.getElementById('node-color').addEventListener('input', (e) => {
                if (selectedNode) {
                    graph.updateNode(selectedNode, { color: e.target.value });
                    document.getElementById('node-color-text').value = e.target.value;
                    render();
                }
            });
            
            document.getElementById('node-color-text').addEventListener('change', (e) => {
                if (selectedNode && /^#[0-9A-F]{6}$/i.test(e.target.value)) {
                    graph.updateNode(selectedNode, { color: e.target.value });
                    document.getElementById('node-color').value = e.target.value;
                    render();
                }
            });
            
            document.getElementById('node-border-color').addEventListener('input', (e) => {
                if (selectedNode) {
                    graph.updateNode(selectedNode, { borderColor: e.target.value });
                    document.getElementById('node-border-text').value = e.target.value;
                    render();
                }
            });
            
            document.getElementById('node-border-text').addEventListener('change', (e) => {
                if (selectedNode && /^#[0-9A-F]{6}$/i.test(e.target.value)) {
                    graph.updateNode(selectedNode, { borderColor: e.target.value });
                    document.getElementById('node-border-color').value = e.target.value;
                    render();
                }
            });
            
            document.getElementById('node-size').addEventListener('change', (e) => {
                if (selectedNode) {
                    graph.updateNode(selectedNode, { size: parseInt(e.target.value) });
                    render();
                }
            });
            
            // 边属性
            document.getElementById('edge-id').addEventListener('change', (e) => {
                if (selectedEdge) {
                    graph.updateEdge(selectedEdge, { id: e.target.value });
                    render();
                }
            });
            
            document.getElementById('edge-label').addEventListener('change', (e) => {
                if (selectedEdge) {
                    graph.updateEdge(selectedEdge, { label: e.target.value });
                    render();
                }
            });
            
            document.getElementById('edge-color').addEventListener('input', (e) => {
                if (selectedEdge) {
                    graph.updateEdge(selectedEdge, { color: e.target.value });
                    document.getElementById('edge-color-text').value = e.target.value;
                    render();
                }
            });
            
            document.getElementById('edge-color-text').addEventListener('change', (e) => {
                if (selectedEdge && /^#[0-9A-F]{6}$/i.test(e.target.value)) {
                    graph.updateEdge(selectedEdge, { color: e.target.value });
                    document.getElementById('edge-color').value = e.target.value;
                    render();
                }
            });
            
            document.getElementById('edge-width').addEventListener('change', (e) => {
                if (selectedEdge) {
                    graph.updateEdge(selectedEdge, { width: parseInt(e.target.value) });
                    render();
                }
            });
            
            document.getElementById('edge-type').addEventListener('change', (e) => {
                if (selectedEdge) {
                    graph.updateEdge(selectedEdge, { type: e.target.value });
                    render();
                }
            });
        }
        
        // 更新缩放显示
        function updateZoomDisplay() {
            document.getElementById('zoom-level').textContent = `${Math.round(zoom * 100)}%`;
        }
        
        // 更新计数器
        function updateCounters() {
            document.getElementById('node-count').textContent = graph.nodes.size;
            document.getElementById('edge-count').textContent = graph.edges.size;
        }
        
        // 调整Canvas尺寸
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            render();
        }
        
        // 渲染图形
        function render() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 保存上下文状态
            ctx.save();
            
            // 应用缩放和平移
            ctx.translate(panX * zoom, panY * zoom);
            ctx.scale(zoom, zoom);
            
            // 绘制边
            graph.edges.forEach(edge => {
                const source = graph.getNode(edge.source);
                const target = graph.getNode(edge.target);
                
                if (!source || !target) return;
                
                // 设置样式
                ctx.strokeStyle = edge.id === selectedEdge ? '#EF4444' : 
                                 edge.id === hoveredEdge?.id ? '#F59E0B' : edge.color;
                ctx.lineWidth = edge.width;
                
                if (edge.type === 'dashed') {
                    ctx.setLineDash([5, 5]);
                } else {
                    ctx.setLineDash([]);
                }
                
                ctx.beginPath();
                
                if (edge.type === 'curved') {
                    // 绘制曲线
                    const controlX = (source.x + target.x) / 2;
                    const controlY = (source.y + target.y) / 2 - 50;
                    ctx.moveTo(source.x, source.y);
                    ctx.quadraticCurveTo(controlX, controlY, target.x, target.y);
                } else {
                    // 绘制直线
                    ctx.moveTo(source.x, source.y);
                    ctx.lineTo(target.x, target.y);
                }
                
                ctx.stroke();
                
                // 绘制边标签
                if (edge.label) {
                    const midX = (source.x + target.x) / 2;
                    const midY = (source.y + target.y) / 2;
                    
                    ctx.font = '12px Inter, sans-serif';
                    ctx.fillStyle = '#333';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // 为曲线边调整标签位置
                    if (edge.type === 'curved') {
                        ctx.fillText(edge.label, midX, midY - 20);
                    } else {
                        ctx.fillText(edge.label, midX, midY - 10);
                    }
                }
            });
            
            // 绘制节点
            graph.nodes.forEach(node => {
                // 计算屏幕坐标
                const x = node.x;
                const y = node.y;
                const size = node.size;
                
                // 绘制节点背景
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                
                // 填充样式
                if (node.id === selectedNode) {
                    ctx.fillStyle = '#FEE2E2';
                } else if (node.id === hoveredNode?.id || node.id === edgeStartNode) {
                    ctx.fillStyle = lightenColor(node.color, 20);
                } else {
                    ctx.fillStyle = node.color;
                }
                ctx.fill();
                
                // 边框样式
                ctx.strokeStyle = node.id === selectedNode ? '#EF4444' : node.borderColor;
                ctx.lineWidth = node.id === selectedNode ? 3 : 2;
                ctx.stroke();
                
                // 绘制节点标签
                ctx.font = '12px Inter, sans-serif';
                ctx.fillStyle = getContrastColor(node.color);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.label, x, y);
            });
            
            // 绘制边工具的临时边
            if (currentTool === 'edge' && edgeStartNode) {
                const startNode = graph.getNode(edgeStartNode);
                if (startNode) {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = (event.clientX - rect.left) / zoom - panX;
                    const mouseY = (event.clientY - rect.top) / zoom - panY;
                    
                    ctx.beginPath();
                    ctx.moveTo(startNode.x, startNode.y);
                    ctx.lineTo(mouseX, mouseY);
                    ctx.strokeStyle = '#64748B';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            // 恢复上下文状态
            ctx.restore();
        }
        
        // 辅助函数：调整颜色亮度
        function lightenColor(color, percent) {
            // 解析RGB值
            let r = parseInt(color.substring(1, 3), 16);
            let g = parseInt(color.substring(3, 5), 16);
            let b = parseInt(color.substring(5, 7), 16);
            
            // 增加亮度
            r = Math.min(255, r + (255 - r) * (percent / 100));
            g = Math.min(255, g + (255 - g) * (percent / 100));
            b = Math.min(255, b + (255 - b) * (percent / 100));
            
            // 转换回十六进制
            const toHex = (c) => Math.round(c).toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }
        
        // 辅助函数：根据背景色获取对比文本色
        function getContrastColor(backgroundColor) {
            // 解析RGB值
            const r = parseInt(backgroundColor.substring(1, 3), 16);
            const g = parseInt(backgroundColor.substring(3, 5), 16);
            const b = parseInt(backgroundColor.substring(5, 7), 16);
            
            // 计算亮度（YIQ公式）
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            
            // 返回对比色
            return brightness > 128 ? '#000000' : '#FFFFFF';
        }
        
        // 添加示例图形
        function addExampleGraph() {
            const node1 = graph.addNode(200, 200, 'A');
            const node2 = graph.addNode(350, 200, 'B');
            const node3 = graph.addNode(200, 350, 'C');
            const node4 = graph.addNode(350, 350, 'D');
            
            graph.addEdge(node1.id, node2.id, '1');
            graph.addEdge(node1.id, node3.id, '2');
            graph.addEdge(node2.id, node4.id, '3');
            graph.addEdge(node3.id, node4.id, '4');
            graph.addEdge(node2.id, node3.id, '5');
            
            updateCounters();
        }
        
        // 初始化应用
        window.addEventListener('load', init);
    </script>
</body>
</html>
